## 136 singleNumber
> 给定数组中出了一个数，其余数均出现两次，找到这个数

* 遍历每个元素
* 两次异或运算^为0
* 0^a=a

## 136 isHappy
> 判断是否是快乐数

* 重复逐位平方求和。
* 将结果构建字典，当运算结果已在字典中时，停止。
* 如果1在字典内（或停止时n=1），则为快乐数。

## ？204 countPrimes
> 寻找比n小的质数有多少

* ？

## 205 isIsomorphic
> 是否同构

* 将s,t用zip打包。
* 此时zip包内相当于s与t的每一位都进行了绑定。
* 对比set(zip)、set(s)、set(t)的长度，相等既是同构。

## 242 isAnagram
> 是否字母异位词

* 比较长短。
* 转换为列表，进行排序
* 全等既是字母异位词。

## 290 wordPattern
> 给定字符串是否符合给定pattern的模式

* 同205，将pattern和str分割为列表。
* 之后用zip()将pattern和str的元素进行绑定。
* 用set进行去重后进行len对比即可确定模式是否相同。
* 对于长度不同的干扰项，需要加入pattern和str元素的原始len比较。

## 349 intersection
> 返回两个给定列表的交集（元素无重复）

* 用set的去重功能和交集（&）运算即可。

## 350 intersectionII
> 返回两个给定列表的交集（元素需重复）

* 遍历其中一个列表
* 对元素进行判断，存在则放进新列表，并在判断列表进行删除。

## 389 findTheDifference
> 给定两个字符串，返回第二个多的字符。

* 遍历删除即可。

## 409 longestPalindrome
> 寻找字符串的最长回文串长度

* 运用collections模块下的Counter容器即可。
* 计数分奇偶数。
* 偶数直接计入长度。
* 计数可贡献计数-1的长度。
* 但一旦出现奇数，回文串中心可容纳一个字符，则至少长度+1

## 438 findAnagrams
> 寻找字符串中所有异位词的起始索引位

* 用给定单词构造以值为键，以count为值的dict。
* 遍历。

## 447 numberOfBoomerangs
> 寻找给定列表里全部“回旋镖”。 (i, j, k其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序））。

* 距离做键，次数为值，构造字典

## 463 islandPerimeter
> 计算“岛”的边长。

* 每个1记四个边，每个相邻减两个边。

## 575 distributeCandies
> 两人均分多种糖果，其中一人最多能分多少种？

* 用len(set())获得糖果类型总数。
* 每种糖果数量-1之和为余量count，代表在不影响糖果多样性的前提下，另一个人可以拿到多少重复的糖果。
* 若count大于等于糖果总数的一半，则有多少种可以拿多少种。
* 若小于总数的一半，则count与总数一半的差值为不能拿的种类数量。

## 594 longestHarmoniousSubsequence
> 最值相差为1的子列的最长长度。

* 用Counter来将全部元素计数。
* 找出差值为1的数对中最多的一个。

## 599 findRestaurant
> 找出两列表中索引和最小的元素。

* 用位置做值元素做键构造字典。
* 找出同元素相加，找到最小索引和。
* 其余的共同元素排在后面。

## 771 numJewelsInStones
> 找出列表J中有多少S中的字符。

* 遍历即可。

