##62 uniquePaths
> 算出从m*n矩阵的一头到另一头有多少种走法。

	* 不存在斜向走法，不存在倒退，所以到一个x，y位置的总方法为走到x-1，y和x，y-1之和。
	* 一直后推到第一排和第一列，第一排和第一列上的位置走法都只有一种。
	* 可以类比杨辉三角来理解。

##63 uniquePathsWithObstacles
> 同62，不过加入了障碍物。

	* 整体规则同62，但是加入前提判断条件，在输入矩阵为1的地方赋值为0即可。

##64 minPathSum
> 同62，求路径上和最小的值。

	* 反向运算，取小值相加即可。

##70 climbStairs
> 求爬梯子有多少种爬法。

	* 逆向思维，爬到最后一个梯子需要爬到倒数第一个和倒数第二个梯子。

##198 rob
> 给定数组，不能相邻取值，找到最大和。

	* 保存两次求和结果，取大值。

##303 sumRange
> 对列表给定区间求和。

	* 因为要多次调用，所以将列表进行预处理。
	* 预处理为当前每位变成从头到当前位置之和。
	* 区间的和即后端位置上的值减去前端位置再前一个位置上的值。

##746 minCostClimbingStairs
> 每步都能选择进一或进二，求遍历列表后的和的最小值。

	* 从开头进行计算，将每一位替换成到达此处的最小值。
	* 最后只需要对比最后两位的大小即可。