# LeetCode List
## 1 twoSum
> 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
	
* enumerate的应用，快速在列表内寻找符合条件的元素。

## 014 longestCommonPrefix
> 寻找给定字符串列表的最长公共开头。

* 用zip(*strs)解包列表。
* 用set()去重，若len为1则为公共前缀。
* 若不为1则输出结果。

## 26 removeDuplicates
> 给定数组，删除重复元素。

* 合理运用set和list的变换，达到去重的功能。

## 27 removeElement
> 原地移除给定值。

* 带条件遍历列表，构造新列表。

## 35 searchInsert
> 在排序数组中找到目标值索引，如果没有目标值，则返回插入位置。

* 用索引值遍历列表，返回合适的索引值。

## 53 maxSubArray
> 找到最大连续子列，并返回其和

* 用双子列遍历列表，子列一保证当前子列为区域最大子列，子列二负责保存最大的子列一。

## 66 plusOne
> 给定代位置代表位数的数组，返回其+1后的数组。[9,9]--[1,0,0]

* 列表转化为int，对int进行+1操作，int转化为字符串，字符串分割转换为列表。

## 88 merge
> 给定两个数组，将其2合并进其1。

* 对要何合并的部分进行遍历，对数值进行对比，将较大的后移。

## 118 Pascal'sTriangle
> 给定层数n，生成n层杨辉三角

* 活用lambda和map功能。

## 119 Pascal'sTriangle II
> 给定层数n，生成第n层杨辉三角

* 同118

## 121 maxProfit
> 给定价格列表，寻求最大利润的一次交易

* 同53，使用双子列遍历，子列一保证区域最大利润值，子列二保证最大子列一。

## 122 maxProfit
> 给定价格列表，寻求多次交易的最大利润

* 遍历列表，对全部隔日差值为正进行求和


## 167 twoSum
> 在给定数组中找到两个数字的位置，目标数字为这两个数字之和。

* 构造字典，其键和值分别等于列表的值和索引，即list[索引]=值————>{'值'：'索引'}

## 169 majorityElement
> 找到众数

* 由于题中众数过半，可构造计数器，相同+1，不同-1，最后一定是>0的数为众数。

## 189 rotate
> 旋转数组（后n位移到前端）

* 数组切片，重新组合。

## 217 containsDuplicate
> 判断列表是否有重复元素

* 应用set的特性，对比长度即可。

## 219 containsNearbyDuplicate
> 判断列表中是否有间隔最大为k位的重复数字

* 同167，用值和索引分别构造字典的键和值，进行遍历条件判断。


## 268 missingNumber
> 列表从0到n，找到中间缺少的那个数

* 设缺位为x，则可以将原数列视为：从1到n+1的n位数组，其第1位到第x位皆减一。
* 故利用等差数列求和公式即可计算x。

## 283 moveZeros
> 将列表中的0移到末尾

* 带索引遍历列表，将全部非0项按索引重排。
* 而后将后端全部写为0。

## 414 thridMax
> 找到列表中第三大的数

* 排序列表，带倒数3来遍历。
* 在非重复数上倒数，输出倒数1的数。

## 443 compress
> 返回按要求压缩后的列表长度。

* 按要求压缩即可。

## 448 findDisappearesdNumbers
> 找到列表中没有出现的数字（1到n）

* 索引方式遍历数组。
* 将值再作为索引，对相应位置的值进行绝对值取负。
* 则最后为正的索引+1即为缺失的数字。

## 475 findRadius
> 找到使列表2中的数字展开后能够覆盖全部列表1中数字的最小半径。

* 双重遍历查找即可。


## 485 findMaxConsecutiveOnes
> 寻找最大连续1的个数

* 将非1数字置为0。
* 将list转为str，对0进行分割。
* 取最大len即可。

## 496 nextGreaterElement
> 输出子列a中每个数字在数列b中右侧下一个更大值的值，没有则填充-1。

* 因为为无重复数列，所以以数列b的值为键，以右侧第一个更大值之差为值构建字典，若没有则填充-1.
* 用子列a逐个查找字典构建结果数列即可。

## 506findRelativeRanks
> 按大小给数组替换成名次。

* 应用lambda进行sort（）。

## 532 findPairs
> 找到数组中全部差值为k的数有多少对

* 构造当前数组的set，构造当前数组所有数字+k的set，用&求两个set的交集，返回len。
* 若k==0，则用collection模块中的Counter()函数，返回全部计数大于1的数字个数。

## 561 arrayPairSum
> 将2n数列拆为n个2位子列，其子列中最小数之和最大

* 输出排序后的步长为2的取值之和即可。

## 566 matrixReshape
> 根据给定条件重塑矩阵

* 先判断数据量是否正确。
* 将原数组化为一行。
* 重组数组。

## 581 findUnsortedSubarray
> 在列表中找到最小未排序子列，返回len

* 将排序后和排序前的数列进行对比即可。

## 605 canPlaceFlowers
> 找到最大个能与1不相邻的位置。

* 将列表前后填充方便运算。
* 遍历填充后的列表逐个判断即可。

## 628 maximumProduct
> 寻找列表里三个数之积的最大值。

* 重排列表后求积。
* 问题分解：
** 后三位符号相同：后三位求积
** 后三位符号不同：最后一位乘前端两位

## 643 findMaxAverage
> 寻找均值最大的k长子列的均值。

* 同53，双子列遍历，子列1确定区域最大，子列2确定最大子列1。

## 645 findErrorNums
> 有序数列中其中一个数被调换成了另一个数，找出这两个数。

* 列表和减去集合和等于重复值之和。
* 原本数列和（1到n）减去集合和为缺值。

## 661 imageSmoother
> 将矩阵中每个数与邻近8个数求平均。

* 用deepcopy会减少很多麻烦。

## 665 checkPossibility
> 确定是否最多用一次改变就能使数列单增。

* 要点在于用两对指针同时对比，1-3,2-4.若两对指针同时False，则直接False。
* 如果只是单个指针False，则计数最后对比<=1即可。

## 674 findLengthOfLCIS
> 找到最长单增子列的长度。

* 用两个指针记录单增子列的位置，对比即可。

## 682 calPoints
> 根据规则算出总和。

* 遍历时逐个判断条件即可。

## 697 findShortestSubArray
> 找到包含全部众数的最大子列

* 用Counter计数
* 两端缩进直到全为众数为止。

## 717 isOneBitCharacter
> 确定最后一位是不是1bit。

* 从头遍历，遇1跳两位，遇0跳一位。

## 724 pivotIndex
> 寻找列表中靠左的一个索引，使索引左右之和相等。

* 先求整个数组之和。
* 再从左向右遍历。
* 遍历时对当前项求和，并在总和中减去。
* 当上面二者相等时即是最靠左的中心索引。

## 747 dominantIndex
> 确定列表中最大数是否至少是其他数的两倍，是的话返回索引。

* 带三个变量遍历数组，确定老大和老二以及老大的索引。
* 判断即可。

## 766 isToeplitzMatrix
> 判断是否为托普利茨矩阵

* 将问题分解为判断每个m[i][j]是否相等于m[i+1][j+1].

## 804 uniqueMorseRepresentations
> 找出给定字符串列表共有几种摩尔斯编码形式。

* 按照ord(字母)-ord(a)的方法在翻译表中找到对应的摩尔斯码并翻译单词。
* 用set来去重，用len来统计数量。

## 812 largestTriangleArea
> 寻找给定点的集合中，能够组成的最大三角形的面积。

* 直接套用三角形三顶点面积公式。
* 用itertools中的combinations(points,3)直接遍历全部三组合输出。

## 830 largeGroupPositions
> 确定大于2的连续字符的起始、终止位置。

* 带计数从头遍历即可。

## 832 flipAndInvertImage
> 按行翻转并取反二进制矩阵。

* 按要求遍历。

## 840 numMagicSquaresInside
> 确定矩阵内有多少幻方。

* 只有1~9。
* 中心必为5。
* 偶在角，奇在变。

## 849 maxDistToClosest
> 找到离其他1最大距离的索引。

* ?